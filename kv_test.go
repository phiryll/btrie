package kv_test

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"iter"
	"math"
	"math/bits"
	rand "math/rand/v2"
	"reflect"
	"slices"
	"strings"
	"testing"

	"github.com/phiryll/kv"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type (
	TestStore = kv.Cloneable[byte]
	Bounds    = kv.Bounds
	keySet    = [][]byte // instances will generally have unique keys

	implDef struct {
		name    string
		factory func() TestStore
	}

	// A description of a store to be tested or benchmarked.
	// Some fields may not be populated depending on the use case.
	//
	// For benchmarking, there is one storeConfig with a given size used by all benchmarks,
	// shared by all store implementations.
	storeConfig struct {
		name string

		// The number of key/value pairs in stores generated by this config.
		// Also the size of entries.
		size int

		// The key/value entries in stores generated by this config.
		entries map[string]byte

		// present/absent[i] = a set of keys of length i that are present/absent.
		// For denser stores, there may be no absent keys of shorter lengths.
		present, absent []keySet

		// forward/reverse Bounds instances to test Range.
		forward, reverse []Bounds
	}

	// A store created by a def.factory(), possibly with entries from config.
	// For some tests, an empty store might be created and config might be nil.
	testStore struct {
		name   string
		store  TestStore
		def    *implDef
		config *storeConfig
	}

	// Used to test Range result sets.
	entry struct {
		key   []byte
		value byte
	}
)

const (
	zero = byte(0)

	// The max key length from testPresentKeys, testAbsentKeys, and testNearKeys.
	testMaxKeyLen = 3
)

var (
	implDefs = []*implDef{
		{"reference", newReference},
		{"pointer-trie", asCloneable(kv.NewPointerTrie[byte])},
		{"array-trie", asCloneable(kv.NewArrayTrie[byte])},
	}

	From       = kv.From
	forwardAll = From(nil).To(nil)
	reverseAll = From(nil).DownTo(nil)

	// Keys used to build test stores.
	// These are in lexicographical order.
	testPresentKeys = keySet{
		{},
		{0},
		{0x23},
		{0x23, 0},
		{0x23, 0xA5},
		{0x23, 0xA6},
		{0xC5},
		{0xC5, 0},
		{0xC5, 0x42},
		{0xC5, 0x43},
	}

	// Non-empty keys very near presentTestKeys, but not in presentTestKeys.
	testAbsentKeys = keySet{
		{0, 0},
		{0x22, 0xFF},
		{0x23, 0, 0},
		{0x23, 0xA4, 0xFF},
		{0x23, 0xA5, 0},
		{0x23, 0xA5, 0xFF},
		{0x23, 0xA6, 0},
		{0xC4, 0xFF},
		{0xC5, 0, 0},
		{0xC5, 0x41, 0xFF},
		{0xC5, 0x42, 0},
		{0xC5, 0x42, 0xFF},
		{0xC5, 0x43, 0},
	}

	// presentTestKeys + absentTestKeys + +/-Inf.
	// Except for the nils, these are in lexicographical order.
	testNearKeys = keySet{
		nil, // -Inf
		{},
		{0},
		{0, 0},
		{0x22, 0xFF},
		{0x23},
		{0x23, 0},
		{0x23, 0, 0},
		{0x23, 0xA4, 0xFF},
		{0x23, 0xA5},
		{0x23, 0xA5, 0},
		{0x23, 0xA5, 0xFF},
		{0x23, 0xA6},
		{0x23, 0xA6, 0},
		{0xC4, 0xFF},
		{0xC5},
		{0xC5, 0},
		{0xC5, 0, 0},
		{0xC5, 0x41, 0xFF},
		{0xC5, 0x42},
		{0xC5, 0x42, 0},
		{0xC5, 0x42, 0xFF},
		{0xC5, 0x43},
		{0xC5, 0x43, 0},
		nil, // +Inf
	}

	testStoreConfigs = createTestStoreConfigs()
)

func nextKey(key []byte) []byte {
	if key == nil {
		panic("key must be non-nil")
	}
	result := make([]byte, len(key)+1)
	copy(result, key)
	result[len(key)] = 0x00
	return result
}

// This may not return the immediate predecessor, since a unique one might not exist.
// For example, {A, B, 0xFF} < {A, B, 0xFF, 0xFF} < ... < {A, B+1}.
func prevKey(key []byte) []byte {
	keyLen := len(key)
	lastByte := key[keyLen-1]
	if lastByte == 0x00 {
		// Return the key with the last byte removed.
		result := make([]byte, keyLen-1)
		copy(result, key)
		return result
	}
	// Return the key with the last byte decremented and an 0xFF added.
	result := make([]byte, keyLen+1)
	copy(result, key[:keyLen-1])
	result[keyLen-1] = lastByte - 1
	result[keyLen] = 0xFF
	return result
}

func TestNextKey(t *testing.T) {
	t.Parallel()
	assert.Panics(t, func() {
		nextKey(nil)
	})
	for _, tt := range []struct {
		key     []byte
		nextKey []byte
	}{
		{[]byte{}, []byte{0}},
		{[]byte{0x23, 0x87, 0x00}, []byte{0x23, 0x87, 0x00, 0x00}},
		{[]byte{0x23, 0x87, 0x12}, []byte{0x23, 0x87, 0x12, 0x00}},
		{[]byte{0x23, 0x87, 0xFF}, []byte{0x23, 0x87, 0xFF, 0x00}},
	} {
		copyKey := append([]byte{}, tt.key...)
		assert.Equal(t, tt.nextKey, nextKey(tt.key))
		// make sure nextKey didn't mutate its arg
		assert.Equal(t, copyKey, tt.key)
	}
}

func TestPrevKey(t *testing.T) {
	t.Parallel()
	assert.Panics(t, func() {
		prevKey(nil)
	})
	assert.Panics(t, func() {
		prevKey([]byte{})
	})
	for _, tt := range []struct {
		key     []byte
		prevKey []byte
	}{
		{[]byte{0}, []byte{}},
		{[]byte{0x23, 0x87, 0x00, 0x00}, []byte{0x23, 0x87, 0x00}},
		{[]byte{0x23, 0x87, 0x00}, []byte{0x23, 0x87}},
		{[]byte{0x23, 0x87, 0x12}, []byte{0x23, 0x87, 0x11, 0xFF}},
		{[]byte{0x23, 0x87, 0xFF}, []byte{0x23, 0x87, 0xFE, 0xFF}},
	} {
		copyKey := append([]byte{}, tt.key...)
		assert.Equal(t, tt.prevKey, prevKey(tt.key))
		// make sure prevKey didn't mutate its arg
		assert.Equal(t, copyKey, tt.key)
	}
}

func asCloneable(factory func() kv.Store[byte]) func() TestStore {
	return func() TestStore {
		store := factory()
		cloneable, ok := store.(TestStore)
		if !ok {
			panic(fmt.Sprintf("%T is not Cloneable", store))
		}
		return cloneable
	}
}

func emptySeqInt(_ func(int) bool) {}

func emptyAdjInt(_ int) iter.Seq[int] {
	return emptySeqInt
}

func emptyPathAdjInt(_ []int) iter.Seq[int] {
	return emptySeqInt
}

func cmpEntryForward(a, b entry) int {
	return bytes.Compare(a.key, b.key)
}

func cmpEntryReverse(a, b entry) int {
	return bytes.Compare(b.key, a.key)
}

func collect(itr iter.Seq2[[]byte, byte]) []entry {
	entries := []entry{}
	for k, v := range itr {
		entries = append(entries, entry{k, v})
	}
	return entries
}

func randomBytes(n int, random *rand.Rand) []byte {
	if n == 0 {
		return []byte{}
	}
	k := (n-1)/8 + 1
	b := make([]byte, k*8)
	for i := range k {
		binary.BigEndian.PutUint64(b[i*8:], random.Uint64())
	}
	return b[:n]
}

func randomByte(random *rand.Rand) byte {
	return byte(random.UintN(256))
}

// Returns a random key of with length chosen from a roughly normal distribution
// with the given mean. Lengths will range from 0 to 2*mean.
func randomKey(meanLen int, random *rand.Rand) []byte {
	const bound = 4.0 // chosen experimentally
	val := random.NormFloat64()
	for val < -bound || val > +bound {
		val = random.NormFloat64()
	}
	// val is in [-bound, +bound], translate that to [0, 2*mean]
	val = (val + bound) * float64(meanLen) / bound
	return randomBytes(int(math.Round(val)), random)
}

func randomFixedLengthKey(keyLen int, random *rand.Rand) []byte {
	return randomBytes(keyLen, random)
}

func shuffle[S ~[]E, E any](slice S, random *rand.Rand) {
	random.Shuffle(len(slice), func(i, j int) {
		slice[i], slice[j] = slice[j], slice[i]
	})
}

// storeConfigs for all possible subsequences of presentKeys.
func createTestStoreConfigs() []*storeConfig {
	result := []*storeConfig{}

	// Every storeConfig here gets the same set of test Bounds.
	var forward, reverse []Bounds
	for i, low := range testNearKeys {
		for _, high := range testNearKeys[i+1:] {
			forward = append(forward, *From(low).To(high))
			reverse = append(reverse, *From(high).DownTo(low))
		}
	}

	// Every bit pattern of i defines which keys are present in that config.
	for keyBits := range 1 << len(testPresentKeys) {
		config := storeConfig{
			fmt.Sprintf("sub-store=%0*b", len(testPresentKeys), keyBits),
			bits.OnesCount(uint(keyBits)),
			map[string]byte{},
			make([]keySet, testMaxKeyLen+1),
			make([]keySet, testMaxKeyLen+1),
			forward,
			reverse,
		}
		mask := 0x01
		for i, k := range testPresentKeys {
			keyLen := len(k)
			if keyBits&mask != 0 {
				config.entries[string(k)] = byte(i)
				config.present[keyLen] = append(config.present[keyLen], k)
			} else {
				config.absent[keyLen] = append(config.absent[keyLen], k)
			}
			mask <<= 1
		}
		for _, k := range testAbsentKeys {
			keyLen := len(k)
			config.absent[keyLen] = append(config.absent[keyLen], k)
		}
		result = append(result, &config)
	}
	return result
}

func TestTestStoreConfigRepeatability(t *testing.T) {
	t.Parallel()
	for i, config := range createTestStoreConfigs() {
		assert.True(t, reflect.DeepEqual(testStoreConfigs[i], config))
	}
}

func createReferenceStore(config *storeConfig) TestStore {
	store := newReference()
	for k, v := range config.entries {
		store.Set([]byte(k), v)
	}
	return store
}

func createTestStores(storeConfigs []*storeConfig) []*testStore {
	result := []*testStore{}
	for _, def := range implDefs {
		for _, config := range storeConfigs {
			store := def.factory()
			for k, v := range config.entries {
				store.Set([]byte(k), v)
			}
			name := fmt.Sprintf("impl=%s/%s", def.name, config.name)
			result = append(result, &testStore{name, store, def, config})
		}
	}
	return result
}

/*
func assertPresent(t *testing.T, key []byte, value byte, store TestStore) {
	actual, ok := store.Get(key)
	assert.True(t, ok)
	assert.Equal(t, value, actual)
	for k, v := range store.Range(forwardAll) {
		if bytes.Equal(key, k) {
			assert.Equal(t, value, v)
			break
		}
	}
	for k, v := range store.Range(reverseAll) {
		if bytes.Equal(key, k) {
			assert.Equal(t, value, v)
			break
		}
	}
}
*/

func assertAbsent(t *testing.T, key []byte, store TestStore) {
	actual, ok := store.Get(key)
	assert.False(t, ok)
	assert.Equal(t, zero, actual)
	actual, ok = store.Delete(key)
	assert.False(t, ok)
	assert.Equal(t, zero, actual)
	for k := range store.Range(forwardAll) {
		assert.NotEqual(t, key, k)
	}
	for k := range store.Range(reverseAll) {
		assert.NotEqual(t, key, k)
	}
}

// Test that store contains only the key/value pairs in entries,
// and that Range(forward/reverse) returns them in the correct order.
func assertSame(t *testing.T, entries map[string]byte, store TestStore) {
	sliceEntries := []entry{}
	for k, expected := range entries {
		actual, ok := store.Get([]byte(k))
		assert.True(t, ok)
		assert.Equal(t, expected, actual)
		sliceEntries = append(sliceEntries, entry{[]byte(k), expected})
	}
	slices.SortFunc(sliceEntries, cmpEntryForward)
	assert.Equal(t, sliceEntries, collect(store.Range(forwardAll)))
	slices.SortFunc(sliceEntries, cmpEntryReverse)
	assert.Equal(t, sliceEntries, collect(store.Range(reverseAll)))
}

func TestNilArgPanics(t *testing.T) {
	t.Parallel()
	for _, def := range implDefs {
		t.Run(def.name, func(t *testing.T) {
			t.Parallel()
			store := def.factory()
			assert.Panics(t, func() {
				store.Set(nil, 0)
			})
			assert.Panics(t, func() {
				store.Get(nil)
			})
			assert.Panics(t, func() {
				store.Delete(nil)
			})
			assert.Panics(t, func() {
				store.Range(nil)
			})
		})
	}
}

// Tests Get/Set/Delete/Range with a specific key and store, which should not contain key.
// The store should be the same after invoking this function.
// Assumes store.Range(forwardAll) works.
func testKey(t *testing.T, key []byte, store TestStore) {
	const value = byte(43)
	const replacement = byte(57)
	existing := map[string]byte{}
	for k, v := range store.Range(forwardAll) {
		existing[string(k)] = v
	}
	require.NotContains(t, existing, string(key))

	assertAbsent(t, key, store)
	assertSame(t, existing, store)

	actual, ok := store.Set(key, value)
	assert.False(t, ok)
	assert.Equal(t, zero, actual)
	existing[string(key)] = value
	assertSame(t, existing, store)

	actual, ok = store.Set(key, replacement)
	assert.True(t, ok)
	assert.Equal(t, value, actual)
	existing[string(key)] = replacement
	assertSame(t, existing, store)

	actual, ok = store.Delete(key)
	assert.True(t, ok)
	assert.Equal(t, replacement, actual)
	assertAbsent(t, key, store)
	delete(existing, string(key))
	assertSame(t, existing, store)
}

// The empty key is often a special case in an implementation.
func TestEmptyKey(t *testing.T) {
	t.Parallel()
	key := []byte{}
	for _, def := range implDefs {
		t.Run(def.name, func(t *testing.T) {
			t.Parallel()
			store := def.factory()
			testKey(t, key, store)
			store.Set([]byte{43, 15}, 94)
			store.Set([]byte{126, 73, 12}, 45)
			testKey(t, key, store)
		})
	}
}

// If String() exists, make sure it doesn't crash.
func TestStoreString(t *testing.T) {
	t.Parallel()
	for _, def := range implDefs {
		t.Run(def.name, func(t *testing.T) {
			t.Parallel()
			store := def.factory()
			if sStore, ok := store.(fmt.Stringer); ok {
				assert.NotPanics(t, func() { _ = sStore.String() })
				store.Set([]byte{}, 73)
				assert.NotPanics(t, func() { _ = sStore.String() })
				store.Set([]byte{43, 15}, 94)
				store.Set([]byte{126, 73, 12}, 45)
				assert.NotPanics(t, func() { _ = sStore.String() })
			}
		})
	}
}

func checkFprint[V any](t *testing.T, expected string, seq iter.Seq2[[]byte, V]) {
	var s strings.Builder
	n, err := kv.Fprint(&s, seq)
	require.NoError(t, err)
	assert.Equal(t, n, s.Len())
	assert.Equal(t, expected, s.String())
}

func TestFprint(t *testing.T) {
	t.Parallel()
	for _, def := range implDefs {
		t.Run(def.name, func(t *testing.T) {
			t.Parallel()
			store := def.factory()
			checkFprint(t, "", store.Range(From(nil).To(nil)))
			checkFprint(t, "", store.Range(From(nil).DownTo(nil)))

			store.Set([]byte{8, 6, 2}, 45)
			store.Set([]byte{1, 2}, 47)
			store.Set([]byte{8, 6, 5}, 53)
			store.Set([]byte{}, 35)
			store.Set([]byte{1, 1, 7, 3, 12}, 16)
			store.Set([]byte{8, 6, 4, 2}, 71)
			store.Set([]byte{1, 1}, 83)

			checkFprint(t, `: 35
0101: 83
. . 07030C: 16
. 02: 47
080602: 45
. . 0402: 71
. . 05: 53
`, store.Range(From(nil).To(nil)))

			checkFprint(t, `080605: 53
. . 0402: 71
. . 02: 45
0102: 47
. 0107030C: 16
. . : 83
: 35
`, store.Range(From(nil).DownTo(nil)))

			// no keys in range
			checkFprint(t, "", store.Range(From([]byte{1, 3}).To([]byte{8, 6, 1})))
			checkFprint(t, "", store.Range(From([]byte{8, 6, 1}).DownTo([]byte{1, 3})))
		})
	}
}

//nolint:gocognit
func TestStores(t *testing.T) {
	t.Parallel()
	for _, test := range createTestStores(testStoreConfigs) {
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()

			// Build the store, testing along the way.
			store := test.def.factory()
			existing := map[string]byte{}
			for k, v := range test.config.entries {
				t.Run("op=set/key="+kv.KeyName([]byte(k)), func(t *testing.T) {
					assertAbsent(t, []byte(k), store)
					assertSame(t, existing, store)

					actual, ok := store.Set([]byte(k), v)
					assert.False(t, ok)
					assert.Equal(t, zero, actual)
					existing[k] = v
					assertSame(t, existing, store)
				})
			}

			for _, keys := range test.config.absent {
				for _, k := range keys {
					t.Run("op=absent/key="+kv.KeyName(k), func(t *testing.T) {
						assertAbsent(t, k, store)
					})
				}
			}

			t.Run("op=range", func(t *testing.T) {
				ref := createReferenceStore(test.config)
				for _, bounds := range test.config.forward {
					assert.Equal(t, collect(ref.Range(&bounds)), collect(store.Range(&bounds)),
						"%s", &bounds)
				}
				for _, bounds := range test.config.reverse {
					assert.Equal(t, collect(ref.Range(&bounds)), collect(store.Range(&bounds)),
						"%s", &bounds)
				}
				// need an early yield for test coverage
				count := 0
				for range store.Range(forwardAll) {
					if count > 3 {
						break
					}
					count++
				}
				count = 0
				for range store.Range(reverseAll) {
					if count > 3 {
						break
					}
					count++
				}
			})
		})
	}
}

//nolint:gocognit
func TestClone(t *testing.T) {
	t.Parallel()
	for _, test := range createTestStores(testStoreConfigs) {
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			original := test.store
			assertSame(t, test.config.entries, original)

			// test that the clone was correct
			store := original.Clone()
			assertSame(t, test.config.entries, store)

			// mutate the clone and test that original hasn't changed
			for k := range test.config.entries {
				store.Delete([]byte(k))
			}
			assertSame(t, map[string]byte{}, store)
			for _, keys := range test.config.absent {
				for i, k := range keys {
					store.Set(k, byte(i))
				}
			}
			assertSame(t, test.config.entries, original)

			// mutate the original and test that the clone hasn't changed
			store = original.Clone()
			for k := range test.config.entries {
				original.Delete([]byte(k))
			}
			assertSame(t, map[string]byte{}, original)
			for _, keys := range test.config.absent {
				for i, k := range keys {
					original.Set(k, byte(i))
				}
			}
			assertSame(t, test.config.entries, store)
		})
	}
}

// Things that failed at one point or another during testing.

func testFail1(t *testing.T, factory func() TestStore) {
	t.Run("fail 1", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{5}, 0)
		assert.Equal(t,
			[]entry{},
			collect(store.Range(From([]byte{5, 0}).To([]byte{6}))))
		assert.Equal(t,
			[]entry{{[]byte{5}, 0}},
			collect(store.Range(From([]byte{4}).To([]byte{5, 0}))))
	})
}

func testFail2(t *testing.T, factory func() TestStore) {
	t.Run("fail 2", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{0xB3, 0x9C}, 184)

		// forgot to check isTerminal
		actual, actualOk := store.Get([]byte{0xB3})
		assert.False(t, actualOk)
		assert.Equal(t, byte(0), actual)

		actual, actualOk = store.Get([]byte{0xB3, 0x9C})
		assert.True(t, actualOk)
		assert.Equal(t, byte(184), actual)
	})
}

func testFail3(t *testing.T, factory func() TestStore) {
	t.Run("fail 3", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{0xB3, 0x9C}, 184)

		actual, actualOk := store.Delete([]byte{0xB3})
		assert.False(t, actualOk)
		assert.Equal(t, byte(0), actual)

		// Make sure the subtree wasn't deleted.
		actual, actualOk = store.Get([]byte{0xB3, 0x9C})
		assert.True(t, actualOk)
		assert.Equal(t, byte(184), actual)
	})
}

func testFail4(t *testing.T, factory func() TestStore) {
	t.Run("fail 4", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{0x50, 0xEF}, 45)
		assert.Equal(t,
			[]entry{},
			collect(store.Range(From([]byte{0x50}).DownTo([]byte{0x15}))))
	})
}

func testFail5(t *testing.T, factory func() TestStore) {
	t.Run("fail 5", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{0x50, 0xEF}, 45)
		assert.Equal(t,
			[]entry{{[]byte{0x50, 0xEF}, 45}},
			collect(store.Range(From([]byte{0xFD}).DownTo([]byte{0x3D}))))
	})
}

func testFail6(t *testing.T, factory func() TestStore) {
	t.Run("fail 6", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{0x50, 0xEF}, 45)
		assert.Equal(t,
			[]entry{{[]byte{0x50, 0xEF}, 45}},
			collect(store.Range(From([]byte{0x51}).DownTo([]byte{0x50}))))
	})
}

func testFail7(t *testing.T, factory func() TestStore) {
	// Failure is due to continuing iteration past false yield().
	// Failure requires the second Set.
	t.Run("fail 7", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{3}, 0)
		store.Set([]byte{4}, 0)
		assert.Equal(t,
			[]entry{},
			collect(store.Range(From([]byte{1}).To([]byte{2}))))
	})
}

func testFail8(t *testing.T, factory func() TestStore) {
	t.Run("fail 8", func(t *testing.T) {
		t.Parallel()
		store := factory()
		store.Set([]byte{}, 1)
		store.Set([]byte{0}, 3)
		store.Set([]byte{0x23}, 4)
		store.Set([]byte{0x23, 0}, 5)
		store.Set([]byte{0x23, 0xA5}, 6)
		assert.Equal(t,
			[]entry{{[]byte{0x23, 0}, 5}},
			collect(store.Range(From([]byte{0x23, 0}).To([]byte{0x23, 0, 0}))))
	})
}

func testFail9(t *testing.T, factory func() TestStore) {
	// Test that removing the last value on a path removes the path.
	// Definite hack to detect this one,
	// but there's no good way to test this using the public API.
	// The alternative would be to have implementation-specific tests,
	// which is probably a better approach, but this works for now.
	t.Run("fail 9", func(t *testing.T) {
		t.Parallel()
		store := factory()
		sStore, ok := store.(fmt.Stringer)
		if !ok {
			t.Skipf("%T does not implement Stringer", store)
		}
		expected := sStore.String()
		key := []byte{0x23}
		store.Set(key, 6)
		store.Delete(key)
		assert.Equal(t, expected, sStore.String())
	})
}

func TestPastFailures(t *testing.T) {
	t.Parallel()
	for _, def := range implDefs {
		factory := def.factory
		t.Run(def.name, func(t *testing.T) {
			t.Parallel()
			testFail1(t, factory)
			testFail2(t, factory)
			testFail3(t, factory)
			testFail4(t, factory)
			testFail5(t, factory)
			testFail6(t, factory)
			testFail7(t, factory)
			testFail8(t, factory)
			testFail9(t, factory)
		})
	}
}
